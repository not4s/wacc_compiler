\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}

\usepackage{fullpage}
\usepackage[margin=2cm]{geometry}
\usepackage[fontsize=12pt]{fontsize}
\usepackage{hyperref}
\usepackage{parskip}
\usepackage{multirow}
\usepackage{float}
\usepackage{graphicx}
\usepackage{enumitem}


% custom syntax highlighting in code blocks
\usepackage{minted}
\usepackage{xcolor} % to access the named colour lightGrey
\definecolor{lightGrey}{gray}{0.975}

\newcommand{\filename}[1]{
    \vspace{1em}
    \texttt{ #1:}
    \vspace*{-0.5em}
}

\newenvironment{codeblock}{
    \VerbatimEnvironment
    \begin{minted}[frame=single,framesep=0.5em,bgcolor=lightGrey,fontsize=\small]{c}
}
{\end{minted}}


% imported from template: allow source code inclusion
\usepackage{listings}
\lstset{
    tabsize=2,
    basicstyle = \ttfamily
}

% imported from template: code style for shell commands
\lstdefinestyle{shell}{
    tabsize=2,
    basicstyle = \ttfamily\small,
}

% imported from template: inline code styling
\newcommand{\shell}[1]{\lstinline!#1!}

\title{WACC Group 06: Project Report}
\author{
    Anton Zhitomirsky \\ \texttt{\href{mailto:ps1620@ic.ac.uk}{az620@ic.ac.uk}}
    \and
    Andrey Popov \\ \texttt{\href{mailto:ap4220@ic.ac.uk}{ap4220@ic.ac.uk}}
    \and
    Jaeho Chung \\ \texttt{\href{mailto:jc2520@ic.ac.uk}{jc2520@ic.ac.uk}}
}

\date\today

\begin{document}

\sloppy

\maketitle

\subsection*{The final product}

\begin{quote}
    An analysis and critical evaluation of the quality of the WACC compiler you
have built. You should consider both whether it meets the functional specification of the project
and whether you judge that it forms a sound basis for future development. You may also wish to
address the performance characteristics of your compiler.
\end{quote}

\subsection*{Project Management}

\begin{quote}
    An analysis of the organisation of your group and your use of project
management tools (such as Git). You should describe how your group was structured, how you
coordinated your work and detail any tools that helped/hindered your progress. You should also
discuss what went well and what you would do differently if you were to do the lab again.

\end{quote}

\subsubsection*{Project Maintenance Tools}

\begin{figure}
  \includegraphics[width=\linewidth]{healthyGitGraph.png}
  \caption{A snapshot of a healthy Git graph structure demonstrating great concurrent development between 4 group memebers}
  \label{fig:gitGraph}
\end{figure}

Developing great code while working with many group members required keeping good Git hygiene and adhering to recognized Git disciplines.

The main branch of the repository was kept clean and 'ready to deploy' by only containing code that was known to compile, run and pass all unit and system tests for a particular milestone. By being meticulous about what code is merged onto the branch this kept the master branch in a state where it could be deployed at any time.

To separate different milestones off the master branch three disjoint and independent branches were created to house the main changes of each developmental stage; the front-end branch, back-end branch and the extension branch. For each milestone, developers create sub-branches off these supplementary branches. 

Merging changes when a branch is days old is extremely difficult and with a high probability of merge conflicts it is difficult to guarantee a safe merge. Instead, Continuous Integration practices were used to provide agile and simple code development by merging frequently and never letting a sub-branch live more than a couple days without merging to the parent branch. Figure \ref{fig:gitGraph} demonstrates a snapshot of a the project's git graphing structure.

Another important application of great git hygiene and great communication lies in meaningful commit messages and discussion channels. To understand what was going on at a glance and who authored the commit, the messages employed the following format:

\verb|[verb describing changes/(authors)+]: short description of context and changes]|
\verb|(any other relevant meta information describing changes)*|

This style of commit messages can be seen in Figure \ref{fig:gitGraph}. 

\subsubsection*{Project Communication and Group Synergy}

Most group communication was done through a Discord group. Here, we had channels for each milestone. This allowed members to communicate about any sort of changes that they'd like to expand on, ask any questions, receive help regarding feature implementation and more. It also was a great medium to share resources; working with a compiler requires a lot of reference material, which was provided in the relevant channels.

Most days, group coding sessions happened in person at the Labs in campus. Being together meant a more dynamic work environment, where people would work collaboratively on a problem if required. This meant that everyone worked efficiently, and any problem was solved faster than if one person was working on it.

Each meeting was prepended with a SCRUM meeting. Each day we would discuss what would be done during the day and the strategies used to solve them. This methodology focused more on working in an iterative fashion inside a fixed time box, rather than building software. We found great use out of this style of group work, as it would efficiently capture the projects general progress and keep group members upto date and included.

\subsubsection*{Testing and Development}

\begin{figure}
  \includegraphics[width=\linewidth]{testScript.png}
  \caption{The helper menu generated with the -h falg explaining all possible options of the testing script}
  \label{fig:testScript}
\end{figure}

Testing remains a mandatory practice during any type of code development and it has never been more prevalent than in this assignment. Where possible, we created unit tests to test implementations of the hidden components of our software, such as the symbol table.

Testing was split into three parts:
\begin{itemize}
    \item Front-end tests made sure that compilation semantically and syntactically invalid programs were halted and correct error messages were presented.
    \item Back-end tests made sure that valid programs produced the correct output by comparing an emulated output of the generated code to the refCompile script. By writing the script in python, we made use of provided libraries for checking the difference between outputs and assembly code if such a need was required.
    \item Extension tests could not use the refCompile script as a foothold because we implemented new features into the language that were not recognised by it. Therefore testing was conducted by comparing the output with a predicted output already in the wacc test.
\end{itemize}

For each of these tests, it was possible to test a directory or all available wacc files in the \shell{sample_programs/} directory. Examples of the scripts can be seen in Figure \ref{fig:testScript}.

Where necessary, new wacc tests were added to the \shell{sample_programs/} directory and conformed to the style and format provided by the department. Such examples can be seen in \shell{sample_programs/valid/structs/}, \shell{sample_programs/invalid/semanticErr/array/} and more.

\subsubsection*{Strengths and Shortcomings}

There was a tendency for group members to work on a feature without communicating it to the rest of the team. As a result, a group member would work on the same problem, only to realize the solution already existed. This led to minor confusion and frustration at times.

Punctuality was also a minor shortcoming, which ended up disrupting the SCRUM meeting cycle because it wouldn't be time efficient to have a separate meeting every time a member arrived. This however wasn't majorly impactful as great progress due to amazing group synergy was achieved without all members being present.

If we were to have more time, we would have made a more thorough testing script. Our primitive script made it difficult to test I/O programs. Therefore these tests were skipped, which contained some bugs themselves which we were too late to fix.

\subsection*{Design Choices and Implementation Details}

\begin{quote}
    An analysis of the design choices that you
made during the WACC project, including your implementation language and tool choices (with
justifications), and any interesting issues you had to overcome during the implementation of your
compiler. You should discuss the design patterns you used when designing your code and why you
chose to use them. You might also want to provide a system architecture diagram for you compiler
to aid this discussion.
\end{quote}


\subsection*{Beyond the Specification}

\begin{quote}
     An evaluation of your extensions to your WACC compiler. You
should describe all of the language extensions, optimisations or other aspects that you have added
to your compiler, especially highlighting \textbf{how these features can be accessed or viewed.} You should
also briefly discuss what future extensions you would add to your compiler if you had more time.
\end{quote}

\subsubsection*{Language Extensions}

\shell{C}-like structs were introduced to WACC to allow for more rich data collections. Much like \shell{C}, these would be used to diversify the programs that could be written and open up a new door into data collections. Previously, this would have relied on carefully setting up arrays and/or pairs in order to store collections of data. 

To begin with, the \shell{WACCLexer.g4} and \shell{WACCParser.g4} were updated to represent the correct behaviour of the structs. These involve struct declarations, struct uses and struct manipulation. Because all struct declarations should happen at the begining of the program (as are functions), structs are parsed first. In \shell{ASTProducer.kt}, when the visitors are traversing the parse tree, we check for semantic errors such as incorrect usages of structs or undefined struct references.

After the front-end is complete the back end generates appropriate assembly code. This code was generated with the help of careful observations from  \hyperlink{ https://godbolt.org/ }{godbolt} website and the ARM Technical Reference Manual.

\subsubsection*{Optimisations}

\subsubsection*{Integrated Development Environments}

\subsubsection*{Future extensions}

The clean and iterative code format has made it easy to add new features to the code. ANTLR helpfully provides a great tree visitor scheme which can be expanded to use and include extra features added in the Lexer and Parser files. Using this made it simple to implement new features to the language.

Having implemented structs, it would also be great to implement classes. Classes would introduce so much potential to WACC and allow it to do so much more. Since classes are comparable to structs in the way they group data, classes would be a job half done before even starting it; the same semantic rules apply for classes and their elements. The only difference being, it would be more difficult to account for class functions, as well as different protection levels on its fields and functions.

\end{document}